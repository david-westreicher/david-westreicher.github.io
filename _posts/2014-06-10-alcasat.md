---
layout: post
title: Alcasat
---

{% include mathjs.html %}

[Alcazar]() is a new pen and paper puzzle game created by [gerard]().
I first heard about Alcazar when [Jonathan Blow]() posted about his interest in the game:
# include twitter

On the game's website you can try out some example games.
The goal of the game is to draw a single path through the maze that visits every cell of the gamefield.

{% include imagecaption.html url="/static/alcazar/example.png" description="A simple example of an Alcazar puzzle (left) and its solution (right)."%}

I tried to solve the 4th puzzle, but after 15 minutes I was thinking about how I could implement a solver for the game.
I closed the tab on my browser and opened up [vim]() and the coding began.


First up was the representation of the game in a 2-dimensional array.

<div class ="leftfloatimg">
{% highlight java %}
x x x x x x x
x 0   0   0 x
x   x x x   x
  0 x 0   0 x
x   x   x   x
  0 x 0   0 x
x   x x x   x
x 0   0   0 x
x x x x x x x
{% endhighlight %}
</div>

In this representation every cell is represented by a "0", a wall by a "x" and a possible line segment by an empty space.
Notice that most of the entries in the array aren't necessary for a solver algorithm because we only care about which lines are set or not.

<br style="clear:both">

## SAT-solving

[SAT](http://en.wikipedia.org/wiki/Boolean_satisfiability_problem) is the
problem of finding a satisfying assignment of a (in this case boolean) logic formula.
Here is an example of a boolean formula:
\\[ f = (x \to y) \wedge (\neg x \vee y) \\]

The [operators](http://en.wikipedia.org/wiki/Logical_connective#List_of_common_logical_connectives) for boolean formulas are \\( \\{ \wedge \text{(and)}, \vee \text{(or)}, \to \text{(implication)}, \neg \text{(not)} \\} \\)
and \\( \\{ x, y, ..\\} \\) represent variables in the domain \\( \\{true,false\\} \\).
An assignment is just a function which *assigns* every variable a truth value.

\\[ a(x) \to true, a(y) \to false \\]

With a formula and an assignment you can evaluate the truth value of the formula
by first replacing the variables with their truth values and then using the [truth
table](http://en.wikipedia.org/wiki/Truth_table) of the operators recursively:

\\[ a(f) = a((x \to y) \wedge (\neg x \vee y))= \\\\
a(x \to y) \wedge a(\neg x \vee y) =\\\\
(a(x) \to a(y)) \wedge (a(\neg x) \vee a(y)) = \\\\
(true \to false) \wedge (\neg true \vee false)=\\\\
false \wedge (false \vee false)=\\\\
false \wedge false=\\\\
false
\\]

As was shown the formula \\( f \\) with the assignment \\( a \\) generates a \\(\text{false}\\) value.
An assignment \\( a \\) of \\( f \\) is called satisfying if and only if \\( a(f)=true \\).
In the example above a satisfying assignment is \\(a(x)=true, a(y)=true \\).
The problem of finding such a satisfying assignment is
[hard](http://en.wikipedia.org/wiki/Boolean_satisfiability_problem#Unrestricted_satisfiability_.28SAT.29) but there exist [free solvers](http://minisat.se/) which solve formulas with million of variables in a matter of seconds.

You might ask yourself how this process might solve alcazar puzzles. Well let's try it
with a simpler example: You want to know if the grass is wet and you know that
it is wet when it rains. First you decide which variables you have in the
statement: \\( wet \text{(the grass is wet)} \\) and \\( rained \text{(it rained)}\\).
It is important that the variables can only be \\(true\\) or \\( false \\).
Next you define a formula which captures the dynamics of the system: \\( rained
\to wet \\).
Now we can find satisfying assignments of the formula when we know that it has
rained:
\\[ rained \wedge ( rained \to wet ) \\]
The formula reads like this: "it rained AND (IF it rained THEN wet)".

Now we hand the formula to our SAT-solver which spits out \\( a(rained)=true, a(wet)=true \\) and we know that
it rained and the grass is wet.
The process of defining the meaning of the variables and generating the formula
is called encoding.

## Encoding of Alcazar puzzles

In the alcazar puzzle we have line segments which can be either turned on or
off. They are therefore a perfect candidate for the set of variables
\\( \\{x_{i,j} \mid puzzle_{}(i,j)=\text{'} \enspace \text{'} \\} \\).
Here's an example of a puzzle where \\( a_{}(x_{2,1})=true\\), \\( a_{}(x_{4,1})=true \\) , \\( a_{}(x_{5,4})=true \\) and for all other \\( a_{}(x_{i,j})=false \\).

{% highlight java %}
x x x x x x x
x 0 - 0 - 0 x
x   x x x   x
  0 x 0   0 x
x   x   x | x
  0 x 0   0 x
x   x x x   x
x 0   0   0 x
x x x x x x x
{% endhighlight %}

Now we need to generate a formula given a puzzle. To make things easier later
we define a helper function \\( two( x_{0}, ..., x_{n-1})\\) which takes
as an input \\( n \\) variables and outputs a formula which is satisfiable if and only if 
2 of the variables are assigned the \\( true \\) value. In math :
\\[ a(two(x_{0}, ..., x_{n-1})) = true \\\\ \iff \\\\
\rvert \rvert \\{x_i \mid a(x_i) = true\\}\rvert \rvert = 2 \\]

The formula is constructed by generating all combinations of the variables and
only leaving 2 variables normal and negating the rest. We join the combinations
with the \\( \wedge \text{(or)}\\) operator:
\\[
two(x_{0},...,x_{n-1}) = \\\\
\bigvee_{i<j} (x_{i} \wedge x_{j} \bigwedge_{k \notin \\{ i,j \\}} \neg x_{k})
\\]

Here's an example of generating the formula for 3 variables and all the
satisfying assignments
\\[two(x_0,x_1,x_2) = (x_0 \wedge x_1 \wedge \neg x_2) \vee \\\\
(x_0 \wedge x_2 \wedge \neg x_1) \vee (x_1 \wedge x_2 \wedge \neg x_0) \\\\
\\]
\\[
\begin{array}{c|lcr}
a_i(x) & x_0 & x_1 & x_2 \\\\
\hline
a_0 & true & true & false \\\\
a_1 & true & false & true \\\\
a_2 & false & true & true
\end{array}
\\]
As expected in all the satisfying assignments the number of variables which
were assigned the \\( true \\) value was 2.
Equipped with this new function we can now tackle the problem of generating a
formula for alcazar puzzles.
{% highlight java %}
x   x 
  0  
x   x
{% endhighlight %}
