---
layout: post
title: Battlecode 2014
---
{% include mathjs.html %}

[Battlecode](http://www.battlecode.org) is a worldwide programming contest organized at the [MIT](http://mit.edu).
> The 6.370 Battlecode programming competition is a unique challenge that combines battle strategy, software engineering and artificial intelligence. In short, the objective is to write the best player program for the computer game Battlecode.

In the contest a 2-player game written in Java is given. Each contestant has to write an [AI](http://en.wikipedia.org/wiki/Artificial_intelligence) for one of the players. After 3 weeks a preliminary tournament is held, where you can qualify for the finals, which is held in front of a live audience, commentated by the organizers.

In 2013 I came across Battlecode, but it was too late for participating in the tournament.
One year later me and a [friend of mine](https://www.github.com/juanolon) entered the tournament with the very Austrian name "[schnitzel](https://github.com/david-westreicher/schnitzel)".

## 2014 Specifications
In the game of 2014 you could win by [sending more GigaGallons milk to space than your opponent](https://github.com/battlecode/battlecode-server/blob/2014-1.3.3/specs.md).
The gamefield is discretized into a grid, where every \\(cell_i\\) in the grid contains \\(c_i\\) cows.
A \\(cell_i\\) can only be traversable if it isn''t water and there is no other robottype on this cell.

All teams started out with a fixed positioned HQ <img style="display:inline;height:1rem;vertical-align:top" src="/static/2014-06-01-battlecode/hq1.png"/> that could spawn SOLDIERS <img style="display: inline;vertical-align:top;height:1rem" src="/static/2014-06-01-battlecode/soldier1.png"/> (aka space cowboys). Each of these soldiers could move (orthogonally and diagonally), shoot, suicide or transform into a PASTR <img style="display: inline;vertical-align:top;height:1rem" src="/static/2014-06-01-battlecode/pastr1.png"/> or NOISE TOWER <img style="display: inline;vertical-align:top;height:1rem" src="/static/2014-06-01-battlecode/noisetower1.png"/>.

A PASTR was the essential building which sends milk generated from nearby cows into space.
A special mechanic of this year's game was that the cows where sensitive to noise.
If a soldier shoots or runs it generates noise and nearby cows run away from the noise source.
This allowed some basic herding of cows, by generating noise in a smart pattern.


{% include imagecaption.html url="/static/2014-06-01-battlecode/game1.png" description="An example of a small map. Green squares represent the number of cows on this cell (the bigger/darker the square, the more cows live there). The cells can be green, grey or blue (grass, road or water). In this example, red has one HQ, five soldiers of which one is shooting and one is transforming into one of the buildings and a PASTR." imagesize="40" %}
Some more details of the game:

* each robot can't share information to the other robots. The only way to communicate is a radio (```int[]```) where we can store one ```int``` per channel
* the execution of the robots actions is turn based
* you have 2000 [bytecodes](http://en.wikipedia.org/wiki/Java_bytecode) per round per robot.
	If you need more bytecodes, your execution is split into several turns and you gain "action delay". Action delay slows down your ability to spawn, move, shoot or transform.
	These constraints boil down to that the player who uses less bytecodes (=efficient code) wins the battles.
* you don't know the map beforehand (so watch out for edge cases!)
* if you kill enemy PASTR you gain 1 GG milk
* a soldier can also milk the cows on the cells it stands on
* the more soldiers you have, the slower they can respawn

To get a better idea of the game, you can watch one of our games in the sprint tournament (the tournament of the first week, that had no impact on the qualifiers) down here:
{% include twitch.html username="m4xmann" videoid="495450723"%}
So we won the first map, and lost the second and third one. Our strategy was to build a "farm" (a NOISETOWER+PASTR) and wait at the farm until the opponent build a PASTR.
Then we would simply attack that enemy PASTR with all of our soldiers. After some time we begin with building a new farm and repeat the process.  
As you might have noticed there are several issues with this strategy. First of all we attack the enemy one by one, which is always a disadvantage versus many enemies.
Second we used a diagonal pattern for our NOISETOWER, which was inferior to our final pattern. Third, we played against the winner of the whole competition :D.
But what was already working really good, was our pathing.

##Pathing
Pathing was one of the first things we implemented.
Normally pathing on a 2D grid is a well known and [solved](http://en.wikipedia.org/wiki/Pathfinding#Algorithms) problem in AI.
What we wanted to use was the classical [A* algorithm](http://en.wikipedia.org/wiki/A*_search_algorithm), but the problem lies in performance.
In the worst case we have a complexity of \\(\mathcal{O}(2^n)\\), where \\(n\\) is the number of cells in the grid.
So what we needed was a radical optimization of the number of nodes that A* has to consider.
We did this by expanding rectangles onto the grid until they hit water and repeating this process until we filled the whole map (except water) with rectangles.
Then we find which rectangles connect to one another and create edges between them.

{% include imagecaption.html url="/static/2014-06-01-battlecode/pathing1.png" description="We only produce 4 nodes and 4 edges with our algorithm, compared to the n nodes we get of a grid with n cells." imagesize="40" %}
This calculation was performed on the HQ after the first SOLDIER was spawned. 
The HQ was now able to calculate the shortest path between two points, by finding out in which rectangle they reside, using A* star to get a path of rectangles and finally calculating a path that consists of visiting the 
Now we had a fast way to calculate the shortest paths between two points, but the

##Strategy
